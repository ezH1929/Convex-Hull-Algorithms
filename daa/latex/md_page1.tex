\chapter{page1}
\hypertarget{md_page1}{}\label{md_page1}\index{page1@{page1}}
\hypertarget{md_page1_subsection1}{}\doxysection{\texorpdfstring{Details\+:}{Details\+:}}\label{md_page1_subsection1}
Sure, let\textquotesingle{}s summarize the Kirkpatrick-\/\+Seidel algorithm with its explanation, complexity analysis, and pseudocode in points\+:\hypertarget{md_page1_autotoc_md0}{}\doxysubsubsection{\texorpdfstring{Explanation\+:}{Explanation\+:}}\label{md_page1_autotoc_md0}

\begin{DoxyEnumerate}
\item {\bfseries{Algorithm Overview}}\+: Kirkpatrick-\/\+Seidel is an incremental convex hull algorithm that divides the set of points into upper and lower hulls and then merges them to obtain the final convex hull.
\item {\bfseries{Upper and Lower Hulls}}\+: It builds the upper and lower hulls separately by iterating through the sorted points.
\item {\bfseries{Merging Hulls}}\+: After constructing the upper and lower hulls, it merges them to obtain the final convex hull.
\item {\bfseries{Orientation Test}}\+: The algorithm relies on the orientation test to determine the convexity of the hull and the relative positions of points.
\end{DoxyEnumerate}\hypertarget{md_page1_autotoc_md1}{}\doxysubsubsection{\texorpdfstring{Complexity\+:}{Complexity\+:}}\label{md_page1_autotoc_md1}

\begin{DoxyItemize}
\item {\bfseries{Time Complexity}}\+:
\begin{DoxyItemize}
\item Sorting\+: O(n log n)
\item Building Upper and Lower Hulls\+: O(n log n)
\item Merging Hulls\+: O(n)
\item Overall Time Complexity\+: O(n log n)
\end{DoxyItemize}
\item {\bfseries{Space Complexity}}\+:
\begin{DoxyItemize}
\item Sorting\+: O(n)
\item Building Upper and Lower Hulls\+: O(n)
\item Merging Hulls\+: O(n)
\item Overall Space Complexity\+: O(n)
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_page1_autotoc_md2}{}\doxysubsubsection{\texorpdfstring{Pseudocode\+:}{Pseudocode\+:}}\label{md_page1_autotoc_md2}

\begin{DoxyCode}{0}
\DoxyCodeLine{Kirkpatrick-\/Seidel(ConvexHullInput):}
\DoxyCodeLine{\ \ \ \ //\ Sort\ points\ lexicographically}
\DoxyCodeLine{\ \ \ \ points.sort((a,\ b)\ =>\ a.x\ -\/\ b.x\ ||\ a.y\ -\/\ b.y)}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ Initialize\ upper\ and\ lower\ hulls}
\DoxyCodeLine{\ \ \ \ upperHull\ =\ []}
\DoxyCodeLine{\ \ \ \ lowerHull\ =\ []}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ Build\ upper\ hull}
\DoxyCodeLine{\ \ \ \ for\ each\ point\ in\ points:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ while\ size(upperHull)\ >=\ 2\ and\ orientation(upperHull[-\/2],\ upperHull[-\/1],\ point)\ !=\ 2:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ upperHull.pop()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ upperHull.append(point)}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ Build\ lower\ hull}
\DoxyCodeLine{\ \ \ \ for\ each\ point\ in\ reverse(points):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ while\ size(lowerHull)\ >=\ 2\ and\ orientation(lowerHull[-\/2],\ lowerHull[-\/1],\ point)\ !=\ 2:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ lowerHull.pop()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ lowerHull.append(point)}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ Remove\ the\ last\ point\ of\ each\ hull\ (repeated)}
\DoxyCodeLine{\ \ \ \ upperHull.pop()}
\DoxyCodeLine{\ \ \ \ lowerHull.pop()}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ //\ Concatenate\ upper\ and\ lower\ hulls}
\DoxyCodeLine{\ \ \ \ convexHull\ =\ lowerHull\ +\ upperHull}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ return\ convexHull}

\end{DoxyCode}


In summary, the Kirkpatrick-\/\+Seidel algorithm efficiently computes the convex hull of a set of points with a time complexity of O(n log n) and a space complexity of O(n). It achieves this by dividing the problem into smaller subproblems, building and merging hulls, and relying on the orientation test for efficiency.

\#\+Plot for Kirk Patrik Algorithm\+:  
\begin{DoxyInlineImage}
\includegraphics[height=\baselineskip,keepaspectratio=true]{Gem.png}
\end{DoxyInlineImage}
    